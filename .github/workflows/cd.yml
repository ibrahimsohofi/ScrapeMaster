name: CD Pipeline

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_run:
    workflows: ["CI Pipeline"]
    types: [completed]
    branches: [ main ]

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  EKS_CLUSTER_NAME: datavault-pro-cluster

jobs:
  # Deploy to Staging Environment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event.workflow_run.conclusion == 'success'
    environment:
      name: staging
      url: https://staging.datavault.pro

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.12.0'

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Install/Upgrade Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Terraform Init
        run: |
          cd infrastructure/terraform
          terraform init -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
                        -backend-config="key=staging/terraform.tfstate" \
                        -backend-config="region=${{ env.AWS_REGION }}"

      - name: Terraform Plan
        run: |
          cd infrastructure/terraform
          terraform plan -var-file="environments/staging.tfvars" \
                        -var="image_tag=${{ github.sha }}" \
                        -out=staging.tfplan

      - name: Terraform Apply
        run: |
          cd infrastructure/terraform
          terraform apply -auto-approve staging.tfplan

      - name: Deploy to Kubernetes (Blue/Green)
        run: |
          cd infrastructure/k8s

          # Update image tag in deployment manifests
          sed -i "s|IMAGE_TAG|${{ github.sha }}|g" staging/deployment.yaml

          # Apply new deployment (Green)
          kubectl apply -f staging/ -n datavault-staging

          # Wait for rollout to complete
          kubectl rollout status deployment/datavault-pro-app -n datavault-staging --timeout=600s

          # Run health checks
          kubectl wait --for=condition=ready pod -l app=datavault-pro -n datavault-staging --timeout=300s

      - name: Run smoke tests
        run: |
          cd tests/e2e
          npm install
          STAGING_URL=https://staging.datavault.pro npm run test:smoke

      - name: Update DataDog deployment markers
        run: |
          curl -X POST "https://api.datadoghq.com/api/v1/events" \
            -H "Content-Type: application/json" \
            -H "DD-API-KEY: ${{ secrets.DATADOG_API_KEY }}" \
            -d '{
              "title": "Staging Deployment",
              "text": "DataVault Pro deployed to staging",
              "tags": ["env:staging", "service:datavault-pro", "version:${{ github.sha }}"]
            }'

      - name: Notify deployment success
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#deployments'
          message: |
            🚀 Successfully deployed to staging!
            Version: ${{ github.sha }}
            URL: https://staging.datavault.pro
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Integration Tests on Staging
  integration-tests:
    name: Integration Tests (Staging)
    runs-on: ubuntu-latest
    needs: [deploy-staging]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          cd tests/e2e
          npm install

      - name: Run full integration test suite
        run: |
          cd tests/e2e
          STAGING_URL=https://staging.datavault.pro \
          API_KEY=${{ secrets.STAGING_API_KEY }} \
          npm run test:integration

      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: integration-test-results
          path: tests/e2e/results/

  # Production Deployment (Manual Approval Required)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [integration-tests]
    if: startsWith(github.ref, 'refs/tags/v') || (github.ref == 'refs/heads/main' && github.event_name == 'push')
    environment:
      name: production
      url: https://datavault.pro

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Create production backup
        run: |
          # Create database backup before deployment
          kubectl exec -n datavault-production deployment/postgres -- \
            pg_dump -U postgres datavault_pro > backup-$(date +%Y%m%d-%H%M%S).sql

          # Upload backup to S3
          aws s3 cp backup-*.sql s3://${{ secrets.BACKUP_BUCKET }}/production/pre-deployment/

      - name: Blue/Green Production Deployment
        run: |
          cd infrastructure/k8s/production

          # Check current deployment color
          CURRENT_COLOR=$(kubectl get service datavault-pro-service -n datavault-production -o jsonpath='{.spec.selector.color}' || echo "blue")

          if [ "$CURRENT_COLOR" = "blue" ]; then
            NEW_COLOR="green"
          else
            NEW_COLOR="blue"
          fi

          echo "Deploying to $NEW_COLOR environment"

          # Update image tag and color in manifests
          sed -i "s|IMAGE_TAG|${{ github.sha }}|g" deployment-$NEW_COLOR.yaml
          sed -i "s|COLOR_TAG|$NEW_COLOR|g" deployment-$NEW_COLOR.yaml

          # Deploy new version
          kubectl apply -f deployment-$NEW_COLOR.yaml -n datavault-production

          # Wait for deployment to be ready
          kubectl rollout status deployment/datavault-pro-$NEW_COLOR -n datavault-production --timeout=600s

          # Run health checks on new deployment
          kubectl wait --for=condition=ready pod -l color=$NEW_COLOR -n datavault-production --timeout=300s

          # Switch traffic to new deployment
          kubectl patch service datavault-pro-service -n datavault-production -p '{"spec":{"selector":{"color":"'$NEW_COLOR'"}}}'

          # Wait and verify traffic switch
          sleep 30

          # Scale down old deployment
          kubectl scale deployment datavault-pro-$CURRENT_COLOR --replicas=0 -n datavault-production

      - name: Run production smoke tests
        run: |
          cd tests/e2e
          PRODUCTION_URL=https://datavault.pro \
          API_KEY=${{ secrets.PRODUCTION_API_KEY }} \
          npm run test:smoke:production

      - name: Update monitoring and alerts
        run: |
          # Update DataDog deployment markers
          curl -X POST "https://api.datadoghq.com/api/v1/events" \
            -H "Content-Type: application/json" \
            -H "DD-API-KEY: ${{ secrets.DATADOG_API_KEY }}" \
            -d '{
              "title": "Production Deployment",
              "text": "DataVault Pro deployed to production",
              "tags": ["env:production", "service:datavault-pro", "version:${{ github.sha }}"]
            }'

          # Update New Relic deployment markers
          curl -X POST "https://api.newrelic.com/v2/applications/${{ secrets.NEW_RELIC_APP_ID }}/deployments.json" \
            -H "X-Api-Key: ${{ secrets.NEW_RELIC_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{
              "deployment": {
                "revision": "${{ github.sha }}",
                "changelog": "Automated deployment via GitHub Actions",
                "description": "Production deployment",
                "user": "${{ github.actor }}"
              }
            }'

      - name: Notify successful production deployment
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#deployments'
          message: |
            🎉 Successfully deployed to PRODUCTION! 🎉
            Version: ${{ github.sha }}
            URL: https://datavault.pro
            Deployed by: ${{ github.actor }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Rollback capability
  rollback-production:
    name: Rollback Production
    runs-on: ubuntu-latest
    if: failure() && needs.deploy-production.result == 'failure'
    needs: [deploy-production]
    environment:
      name: production

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Rollback to previous version
        run: |
          # Get previous deployment
          kubectl rollout undo deployment/datavault-pro-app -n datavault-production

          # Wait for rollback to complete
          kubectl rollout status deployment/datavault-pro-app -n datavault-production --timeout=300s

      - name: Notify rollback
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#deployments'
          message: |
            ⚠️ ROLLBACK EXECUTED for production deployment
            Failed deployment has been rolled back to previous version
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
